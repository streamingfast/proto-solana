syntax = "proto3";

package sf.solana.codec.v1;

option go_package = "github.com/streamingfast/sf-solana/pb/sf/solana/codec/v1;pbcodec";

import "google/protobuf/any.proto";

message Block {
  bytes id = 1;  // corresponds to the Slot id (or hash)
  uint64 number = 2; // corresponds to the Slot number for this block
  uint32 version = 3;
  bytes previous_id = 4; // corresponds to the previous_blockhash, might skip some slots, so beware
  uint64 previous_block = 5;
  uint64 genesis_unix_timestamp = 6;
  uint64 clock_unix_timestamp = 7;
  uint64 root_num = 8;

  bytes last_entry_hash = 9;

  repeated Transaction transactions = 10;
  uint32 transaction_count = 11;

  bool has_split_account_changes = 12;
  string account_changes_file_ref = 13;
}

message Batch {
  repeated Transaction transactions = 1;
}

// Bundled in separate files, referenced by `account_changes_file_ref`
message AccountChangesBundle {
  // Maps to the index of the `repeated` field for Block::transactions
  repeated AccountChangesPerTrxIndex transactions = 1;
}

message AccountChangesPerTrxIndex {
  bytes TrxId = 1;

  // Maps to the index within the `repeated` field of the proto for
  // Transaction::instructions
  repeated AccountChangesPerInstruction instructions = 2;
}

message AccountChangesPerInstruction {
  // Data to be put in Instruction::account_changes
  repeated AccountChange changes = 1;
}

message Transaction {
  // The transaction ID corresponds to the _first_
  // signature. Additional signatures are in `additional_signatures`.
  bytes id = 1;

  // Index from within a single Slot, deterministically ordered to the
  // best of our ability using the transaction ID as a sort key for
  // the batch of transactions executed in parallel.
  uint64 index = 2;

  repeated bytes additional_signatures = 3;

  MessageHeader header = 4;
  // From the original Message object
  repeated bytes account_keys = 5;
  // From the original Message object
  bytes recent_blockhash = 6;

  // What follows Once executed these can be set:
  repeated string log_messages = 7;
  // Instructions, containing both top-level and nested transactions
  repeated Instruction instructions = 8;

  bool failed = 9;
  TransactionError error = 10;
}

message MessageHeader  {
  uint32 num_required_signatures = 1;
  uint32 num_readonly_signed_accounts = 2;
  uint32 num_readonly_unsigned_accounts = 3;
}


/**
- instr1 (id=1, parent=0)
- instr2 (id=2, parent=0) (pubkey1 is writable)
  - instr3 (id=3, parent=2) (pubkey1 is writable)
     - instr4 (id=4, parent=3) (pubkey1 is writable)
        - instr5 (id=5, parent=4) (pubkey1 is writable, mutates pubkey1)
       collect delta of pubkey1
     collect delta of pubkey1 ONLY IF CHANGED AGAIN, from last time we took a snapshot of it.
  collect delta of pubkey1
- instr6 (id=6, parent=0)
 */

message Instruction {
  bytes program_id = 3;
  repeated bytes account_keys = 4;
  bytes data = 5;

  // What follows is execution trace data, could be empty for un-executed transactions.

  uint32 ordinal = 6;
  uint32 parent_ordinal = 7;
  uint32 depth = 8;

  repeated BalanceChange balance_changes = 9;
  repeated AccountChange account_changes = 10;

  bool failed = 15;
  InstructionError error = 16;
}

message BalanceChange {
  bytes pubkey = 1;
  uint64 prev_lamports = 2;
  uint64 new_lamports = 3;
}

message AccountChange {
  bytes pubkey = 1;
  bytes prev_data = 2;
  bytes new_data = 3;
  uint64 new_data_length = 4;
}

message TransactionError {
  TransactionErrorType type = 1;
  google.protobuf.Any payload = 2;
}

message TransactionInstructionError {
  uint32 Index = 1;
  InstructionError error = 2;
}

enum TransactionErrorType {
  /// An account is already being processed in another transaction in a way
  /// that does not support parallelism
  // Account in use"
  ACCOUNT_IN_USE = 0;

  /// A `Pubkey` appears twice in the transaction's `account_keys`.  Instructions can reference
  /// `Pubkey`s more than once but the message must contain a list with no duplicate keys
  // Account loaded twice"
  ACCOUNT_LOADED_TWICE = 1;

  /// Attempt to debit an account but found no record of a prior credit.
  // Attempt to debit an account but found no record of a prior credit."
  ACCOUNT_NOT_FOUND = 2;

  /// Attempt to load a program that does not exist
  // Attempt to load a program that does not exist"
  PROGRAM_ACCOUNT_NOT_FOUND = 3;

  /// The from `Pubkey` does not have sufficient balance to pay the fee to schedule the transaction
  // Insufficient funds for fee"
  INSUFFICIENT_FUNDS_FOR_FEE = 4;

  /// This account may not be used to pay transaction fees
  // This account may not be used to pay transaction fees"
  INVALID_ACCOUNT_FOR_FEE = 5;

  /// The bank has seen this `Signature` before. This can occur under normal operation
  /// when a UDP packet is duplicated, as a user error from a client not updating
  /// its `recent_blockhash`, or as a double-spend attack.
  // The bank has seen this signature before"
  DUPLICATE_SIGNATURE = 6;

  /// The bank has not seen the given `recent_blockhash` or the transaction is too old and
  /// the `recent_blockhash` has been discarded.
  // Blockhash not found"
  BLOCKHASH_NOT_FOUND = 7;

  /// An error occurred while processing an instruction. The first element of the tuple
  /// indicates the instruction index in which the error occurred.
  // Error processing Instruction {0}: {1}"
  INSTRUCTION_ERROR = 8;

  /// Loader call chain is too deep
  // Loader call chain is too deep"
  CALL_CHAIN_TOO_DEEP = 9;

  /// Transaction requires a fee but has no signature present
  // Transaction requires a fee but has no signature present"
  MISSING_SIGNATURE_FOR_FEE = 10;

  /// Transaction contains an invalid account reference
  // Transaction contains an invalid account reference"
  INVALID_ACCOUNT_INDEX = 11;

  /// Transaction did not pass signature verification
  // Transaction did not pass signature verification"
  SIGNATURE_FAILURE = 12;

  /// This program may not be used for executing instructions
  // This program may not be used for executing instructions"
  INVALID_PROGRAM_FOR_EXECUTION = 13;

  /// Transaction failed to sanitize accounts offsets correctly
  /// implies that account locks are not taken for this TX, and should
  /// not be unlocked.
  // Transaction failed to sanitize accounts offsets correctly"
  SANITIZE_FAILURE = 14;

  // Transactions are currently disabled due to cluster maintenance"
  CLUSTER_MAINTENANCE = 15;
}

message InstructionError {
  InstructionErrorType type = 2;
  google.protobuf.Any payload = 3;
}

message InstructionErrorCustom {
  uint32 id = 1;
}

enum InstructionErrorType {
  /// Deprecated! Use CustomError instead! The program instruction returned an error
  // generic instruction error
  GENERIC_ERROR = 0;
  /// The arguments provided to a program were invalid
  // invalid program argument
  INVALID_ARGUMENT = 1;

  /// An instruction's data contents were invalid
  // invalid instruction data
  INVALID_INSTRUCTION_DATA = 2;

  /// An account's data contents was invalid
  // invalid account data for instruction
  INVALID_ACCOUNT_DATA = 3;

  /// An account's data was too small
  // account data too small for instruction
  ACCOUNT_DATA_TOO_SMALL = 4;

  /// An account's balance was too small to complete the instruction
  // insufficient funds for instruction
  INSUFFICIENT_FUNDS = 5;

  /// The account did not have the expected program id
  // incorrect program id for instruction
  INCORRECT_PROGRAM_ID = 6;

  /// A signature was required but not found
  // missing required signature for instruction
  MISSING_REQUIRED_SIGNATURE = 7;

  /// An initialize instruction was sent to an account that has already been initialized.
  // instruction requires an uninitialized account
  ACCOUNT_ALREADY_INITIALIZED = 8;

  /// An attempt to operate on an account that hasn't been initialized.
  // instruction requires an initialized account
  UNINITIALIZED_ACCOUNT = 9;

  /// Program's instruction lamport balance does not equal the balance after the instruction
  // sum of account balances before and after instruction do not match
  UNBALANCED_INSTRUCTION = 10;

  /// Program modified an account's program id
  // instruction modified the program id of an account
  MODIFIED_PROGRAM_ID = 11;

  /// Program spent the lamports of an account that doesn't belong to it
  // instruction spent from the balance of an account it does not own
  EXTERNAL_ACCOUNT_LAMPORT_SPEND = 12;

  /// Program modified the data of an account that doesn't belong to it
  // instruction modified data of an account it does not own
  EXTERNAL_ACCOUNT_DATA_MODIFIED = 13;

  /// Read-only account's lamports modified
  // instruction changed the balance of a read-only account
  READONLY_LAMPORT_CHANGE = 14;

  /// Read-only account's data was modified
  // instruction modified data of a read-only account
  READONLY_DATA_MODIFIED = 15;

  /// An account was referenced more than once in a single instruction
  // Deprecated, instructions can now contain duplicate accounts
  // instruction contains duplicate accounts
  DUPLICATE_ACCOUNT_INDEX = 16;

  /// Executable bit on account changed, but shouldn't have
  // instruction changed executable bit of an account
  EXECUTABLE_MODIFIED = 17;

  /// Rent_epoch account changed, but shouldn't have
  // instruction modified rent epoch of an account
  RENT_EPOCH_MODIFIED = 18;

  /// The instruction expected additional account keys
  // insufficient account keys for instruction
  NOT_ENOUGH_ACCOUNT_KEYS = 19;

  /// A non-system program changed the size of the account data
  // non-system instruction changed account size
  ACCOUNT_DATA_SIZE_CHANGED = 20;

  /// The instruction expected an executable account
  // instruction expected an executable account
  ACCOUNT_NOT_EXECUTABLE = 21;

  /// Failed to borrow a reference to account data, already borrowed
  // instruction tries to borrow reference for an account which is already borrowed
  ACCOUNT_BORROW_FAILED = 22;

  /// Account data has an outstanding reference after a program's execution
  // instruction left account with an outstanding reference borrowed
  ACCOUNT_BORROW_OUTSTANDING = 23;

  /// The same account was multiply passed to an on-chain program's entrypoint, but the program
  /// modified them differently.  A program can only modify one instance of the account because
  /// the runtime cannot determine which changes to pick or how to merge them if both are modified
  // instruction modifications of multiply-passed account differ
  DUPLICATE_ACCOUNT_OUT_OF_SYNC = 24;

  /// Allows on-chain programs to implement program-specific error types and see them returned
  /// by the Solana runtime. A program-specific error may be any type that is represented as
  /// or serialized to a u32 integer.
  // custom program error: {0:#x}
  CUSTOM = 25;

  /// The return value from the program was invalid.  Valid errors are either a defined builtin
  /// error value or a user-defined error in the lower 32 bits.
  // program returned invalid error code
  INVALID_ERROR = 26;

  /// Executable account's data was modified
  // instruction changed executable accounts data
  EXECUTABLE_DATA_MODIFIED = 27;

  /// Executable account's lamports modified
  // instruction changed the balance of a executable account
  EXECUTABLE_LAMPORT_CHANGE = 28;

  /// Executable accounts must be rent exempt
  // executable accounts must be rent exempt
  EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 29;

  /// Unsupported program id
  // Unsupported program id
  UNSUPPORTED_PROGRAM_ID = 30;

  /// Cross-program invocation call depth too deep
  // Cross-program invocation call depth too deep
  CALL_DEPTH = 31;

  /// An account required by the instruction is missing
  // An account required by the instruction is missing
  MISSING_ACCOUNT = 32;

  /// Cross-program invocation reentrancy not allowed for this instruction
  // Cross-program invocation reentrancy not allowed for this instruction
  REENTRANCY_NOT_ALLOWED = 33;

  /// Length of the seed is too long for address generation
  // Length of the seed is too long for address generation
  MAX_SEED_LENGTH_EXCEEDED = 34;

  /// Provided seeds do not result in a valid address
  // Provided seeds do not result in a valid address
  INVALID_SEEDS = 35;

  /// Failed to reallocate account data of this length
  // Failed to reallocate account data
  INVALID_REALLOC = 36;

  /// Computational budget exceeded
  // Computational budget exceeded
  COMPUTATIONAL_BUDGET_EXCEEDED = 37;

  /// Cross-program invocation with unauthorized signer or writable account
  // Cross-program invocation with unauthorized signer or writable account
  PRIVILEGE_ESCALATION = 38;

  // Failed to create program execution environment
  PROGRAM_ENVIRONMENT_SETUP_FAILURE = 39;

  // Program failed to complete
  PROGRAM_FAILED_TO_COMPLETE = 40;

  // Program failed to compile
  PROGRAM_FAILED_TO_COMPILE = 41;

  // Account is immutable
  IMMUTABLE = 42;

  // Incorrect authority provided
  INCORRECT_AUTHORITY = 43;
}